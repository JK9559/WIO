>[剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)
>
>请实现一个函数用来匹配包含 ```'.'``` 和 ```'*'``` 的正则表达式。模式中的字符 ```'.'``` 表示任意一个字符，而 ```'*'``` 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 ```"aaa"``` 与模式 ```"a.a"``` 和 ```"ab*ac*a"``` 匹配，但与 ```"aa.a"``` 和 ```"ab*a"``` 均不匹配。
>
>**示例1**
```
输入：
  s = "aa"
  p = "a*"
输出：
  true
```

```golang
// Golang版
func isMatch(s string, p string) bool {
    // dp[i][j] 表示 长度为 i 的 s 和 长度为 j 的 p 是否匹配
    // s[i-1] 为 长度为 i 时的 s 的最后一个字符，同理 p[j-1] 为 长度为 j 时的 p 的最后一个字符
    dp := make([][]bool, len(s)+1)
    for i := 0; i < len(dp); i++ {
        dp[i] = make([]bool, len(p)+1)
    }
    // 前提 *有三种含义
    // 含义为0 代表 b* 等同于 空
    // 含义为1 代表 b* 等同于 b
    // 含义为2 代表 b* 等同于 bb或者多个b
    // dp[i][j] 含义是 从头数长度为i的s 和长度为j的p 是否能匹配 --> 注意此时 s最后一个字母下标为i-1 p最后一个字母下标为j-1
    dp[0][0] = true
    for i := 2; i <= len(p); i++ {
        // 当遇到当前p的字符为* 那么两种情况：
        // 1 p的i-1长度已经和s匹配 p当前的* 含义为1
        // 2 p的i-2长度已经和s匹配 p当前的* 含义是0
        if p[i-1] == '*' {
            dp[0][i] = dp[0][i-1] || dp[0][i-2]
        }
    }
    for i := 1; i <= len(s); i++ {
        for j := 1; j <= len(p); j++ {
            // 当当前p的字符和当前s的字符一致 或者 当前p字符为. 那么等同于除去这两个字母 比较前面的
            if p[j-1] == s[i-1] || p[j-1] == '.' {
                dp[i][j] = dp[i-1][j-1]
                // 当 当前p的字母为*
            } else if j >= 2 && p[j-1] == '*' {
                // 如果当前s的字母 和 p的上一个字母不同 并且 p的上一个字母不是. 的情况下 *的含义就是0
                if s[i-1] != p[j-2] && p[j-2] != '.' {
                    dp[i][j] = dp[i][j-2]
                } else {
                    // 如果s当前字母和p的上一个字母相同
                    // *含义0 dp = dp[i][j-2]
                    // *含义1 dp = dp[i][j-1]
                    // *含义2 dp = dp[i-1][j] 为啥 因为s当前字母和p上一个相同又因为p当前为* 所以：p以后可以通过*多复制一个字母出来
                    dp[i][j] = dp[i][j-1] || dp[i][j-2] || dp[i-1][j]
                }
            }
        }
    }
    return dp[len(s)][len(p)]
}
```