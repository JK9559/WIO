1. 对象的内存布局如何？
    + 三部分：对象头、实例数据、对齐填充
    + 对象头：
        + ```MarkWord``` ：存储对象自身的运行时数据，如哈希码， ```GC``` 分代年龄，锁状态标志，线程持有的锁等等。 32 位系统 4 字节 64 位 8 字节
        + 类型指针：对象指向类元数据（```Class Metadata```）的指针。 32 位系统 4 字节 64 位 8 字节
        + 数组长度：当为数组对象时存在。 4 个字节
    + 实例数据：
        + 由所有成员变量决定，对于 ```reference``` 类型来说，在 32 位系统上占用 4 ```bytes``` , 在 64 位系统上占用 8 ```bytes```
    + 对齐填充：保证对象占用空间为 8 的倍数
2. 指针压缩：
    + 问题的引出：
        + 当使用 64 位 ```JVM``` 时，可使用的内存更多更有优势，但是相应的问题是，因为 64 位 ```JVM``` 相比于 32 位 ```JVM``` ，需要的寻址空间变大了，所以，指针的空间也变大了。就导致占用的空间也会增大。因此，引出了指针压缩。
    + 指针压缩做了什么？
        + 压缩了一些指针占用内存的大小，当然是在不改变指针指向的情况下。
    + 哪些指针会被压缩？
        + 每个 ```Class``` 的属性指针（静态成员变量）
        + 每个对象的属性指针
        + 普通对象数组的每个元素指针
    + 指针压缩原理
        + 总述：不再保存所有引用，而是每隔 8 个字节保存一个引用
        + Why：
            1. 一个对象，可以确定的是一定是 8 字节的倍数。也就说 对象起始地址低三位肯定是 000 。因此可以省下来 3 位。
            2. 所以压缩其实就是将偏移量 除以 8 保存起来，作为压缩后的偏移量。使用的时候 再乘以 8 。
            3. 使用压缩指针 可以表达的地址范围 由原来的32位 变成了 32+3=35 位。
        + 结论：
            + 当堆内存 ```4G=2^32bits``` 时，不用压缩指针。
            + 当堆内存 ```4G``` 到 ```32G``` 之间 ```2^32~2^35bits``` 。使用压缩指针。
            + 当堆内存大于 ```32G``` 无法使用压缩指针优化。
                + 原因：内存越大导致寻址范围越大 导致了右移 3 位的压缩可能会造成精度丢失 此后的左移 3 位数据无法还原。